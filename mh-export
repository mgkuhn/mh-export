#!/usr/bin/perl -w
# Convert Computer Laboratory MH mail files into mboxrd format
# http://www.qmail.org/qmail-manual-html/man5/mbox.html

# This script is meant as a replacement for packf, fixing the following
# problems:
#
#   - discards Resent: headers that have been prepended to a message
#     by the MUA after it was delivered (exmh adds these, but they
#     are not RFC 2822 and can preceed the From_ line)
#
#   - preserves existing From_ lines, rather than making up a
#     new one instead
#
#   - Perform the reversible >From_ escaping defined by Rahul Dhesi
#     (packf appears to generate mboxo rather than mboxrd)
#

use strict;

my $debug = 0;

sub process {
    my ($msg) =@_;
    
    # strip leading Resent:/Replied: headers
    my %stripped;
    while ($msg =~ s/^(Resent|Replied|X-\S+): (.*)\n//) {
	push @{$stripped{$1}}, $2;
    }

    # strip leading From_ line
    my ($envsender, $date, $moreinfo);

    if ($msg =~ s/^From ([^ \t\n]+) (.{24})(.*)\n//) {
	$envsender = $1;
	$date = $2;
	$moreinfo = $3;
    }
    die("not an asctime date: '$date'\n")
	if defined $date and $date !~ /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [ 0-3][0-9] [012]\d:[0-5]\d:[0-5]\d [12]\d\d\d$/;

    # parse other header fields
    my %header;
    while ($msg =~ /\G(\S+?):[ \t]*((?:.+|\n[ \t]+)*)\n/g) {
	push @{$header{$1}}, $2;
    }

    if ($debug) {
	foreach my $h (keys %header) {
	    foreach my $v (@{$header{$h}}) {
		print "$h= $v\n";
	    }
	}
    }

    # restore stripped headers
    foreach my $s (sort {$a cmp $b} keys %stripped) {
	while (my $r = pop @{$stripped{$s}}) {
	    $r = "$s: $r\n";
	    $msg = $r . $msg;
	}
    }

    # escape spurious From_ lines
    $msg =~ s/^(>*From )/>$1/gm;
    die("unterminated final line") unless $msg =~ /\n$/; 
    $msg .= "\n" unless $msg =~ /\n\n$/;  # seems only needed for sent messages

    # prepare fake From_ line if
    if (!defined $date) {
	if (defined $header{'Delivery-date'} &&
	    defined ${$header{'Delivery-date'}}[0]) {
	    ${$header{'Delivery-date'}}[0] =~ /(Mon|Tue|Wed|Thu|Fri|Sat|Sun), ([ 0-3][0-9]) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ([12]\d\d\d) ([012]\d:[0-5]\d:[0-5]\d) (\+0[01]00)/
		or die("unexpected delivery-date '${$header{'Delivery-date'}}[0]'");
	    $date = "$1 $3 $2 $5 $4";  # use local time (for simplicity)
	} else {
	    $date = 'Thu Jan  1 00:00:00 1970'; # dummy date
	}
    }
    if (!defined $envsender) {
	if (defined $header{'Return-path'} &&
	    defined ${$header{'Return-path'}}[0]) {
	    if (${$header{'Return-path'}}[0] =~ /^<([^ \t\n]+)>$/ ||
		${$header{'Return-path'}}[0] =~ /^([^ \t\n]+)$/) {
		$envsender = $1;
	    } else {
		die("unexpected Return-path '${$header{'Return-path'}}[0]'\n");	
	    }
	} else {
	    $envsender = '-';
	}
    }
    if (!defined $moreinfo) {
	$moreinfo = '';
    }

    return "From $envsender $date$moreinfo\n" . $msg;
}

foreach my $fn (@ARGV) {
    if (-d $fn) { warn("$fn: skipping directory\n"); next; }
    open my $f, '<', $fn or die("Cannot read '$fn': $!\n");
    local $/;  # enable localized slurp mod
    my $msg = <$f>;
    close $f;
    my $out;
    eval { 
	local $SIG{__WARN__} = sub { die $_[0] };
	$out = process($msg);
    };
    die("$fn: $@") if $@;
    print $out;
}
